micronaut:
  application:
    name: documents-service
  server:
    host: localhost
    port: 8080
---
documents:
  policies-s3-bucket: policies
---
minio:
  tenant-endpoint: "${MINIO_TENANT_ENDPOINT:http://localhost:9000}"
  svc-access-key: "${MINIO_SVC_ACCESS_KEY:minioSvcAccessKey}"
  svc-secret-key: "${MINIO_SVC_SECRET_KEY:minioSvcSecretKey}"
---
postgres:
  host: ${PG_HOST:localhost}
  port: ${PG_PORT:5432}
  database: ${PG_DBNAME:document}
  username: ${PG_USER:document}
  password: ${PG_PASSWORD:document}
  ssl: ${PG_SSL:false}
---
# This is only to allow Micronaut to bootstrap DataSource + JPA;
# overridden at runtime by PostgresDatasourceConfigurationListener#onCreated(BeanCreatedEvent<DatasourceConfiguration>)
datasources:
  default:
    driverClassName: org.postgresql.Driver
    url: "jdbc:postgresql://localhost:5432/document"
    username: ${PG_USER:document}
    password: ${PG_PASSWORD:document}
---
jpa:
  default:
    packages-to-scan:
      - 'pl.altkom.asc.lab.micronaut.poc.documents.domain'
    properties:
      hibernate:
        hbm2ddl:
          auto: update
        show_sql: false
---
jackson:
  serialization:
    failOnEmptyBeans: false
    writeDatesAsTimestamps: true
---
kafka:
  bootstrap:
    servers: "${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}"
---
tracing:
  zipkin:
    enabled: true
    http:
      url: "http://${ZIPKIN_HOST:localhost}:${ZIPKIN_PORT:9411}"
      sampler:
        probability: 1.0 # Configuration taking 100% of the request to be processed by Zipkin. In a real production system, that could be overwhelming.
---
jsreport:
  host: ${JSREPORT_HOST:localhost}
  port: ${JSREPORT_PORT:5488}
