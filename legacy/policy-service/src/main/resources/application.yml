micronaut:
  application:
    name: policy-service
  server:
    host: localhost
    port: 8080
---
postgres:
  host: ${PG_HOST:localhost}
  port: ${PG_PORT:5432}
  database: ${PG_DBNAME:policy}
  username: ${PG_USER:policy}
  password: ${PG_PASSWORD:policy}
  ssl: ${PG_SSL:false}
---
# This is only to allow Micronaut to bootstrap DataSource + JPA;
# overridden at runtime by PostgresDatasourceConfigurationListener#onCreated(BeanCreatedEvent<DatasourceConfiguration>)
datasources:
  default:
    driverClassName: org.postgresql.Driver
    url: "jdbc:postgresql://localhost:5432/policy"
    username: ${PG_USER:policy}
    password: ${PG_PASSWORD:policy}
---
jpa:
 default:
    packages-to-scan:
        - 'pl.altkom.asc.lab.micronaut.poc.policy.domain'
    properties:
        hibernate:
            hbm2ddl:
                auto: create-drop
            show_sql: true
---
jackson:
  serialization:
    failOnEmptyBeans: false
    writeDatesAsTimestamps: true
---
kafka:
#  embedded:
#    enabled: true
  bootstrap:
    servers: "${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}"
---
endpoints:
  health:
    enabled: true
    sensitive: false
  env:
    enabled: false
    sensitive: false
---
tracing:
  zipkin:
    enabled: true
    http:
      url: "http://${ZIPKIN_HOST:localhost}:${ZIPKIN_PORT:9411}"
      sampler:
        probability: 1.0 # Configuration taking 100% of the request to be processed by Zipkin. In a real production system, that could be overwhelming.
