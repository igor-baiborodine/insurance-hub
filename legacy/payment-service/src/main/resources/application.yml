micronaut:
  application:
    name: payment-service
  server:
    host: localhost
    port: 8080
---
kafka:
  bootstrap:
    servers: "${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}"
---
hystrix:
  stream:
    enabled: true
---
tracing:
  zipkin:
    enabled: true
    http:
      url: "http://${ZIPKIN_HOST:localhost}:${ZIPKIN_PORT:9411}"
      sampler:
        probability: 1.0 # Configuration taking 100% of the request to be processed by Zipkin. In a real production system, that could be overwhelming.
---
payments:
    import-s3-bucket: payments-import
    import-fixed-rate: "8h"
---
minio:
  tenant-endpoint: "${MINIO_TENANT_ENDPOINT:http://localhost:9000}"
  svc-access-key: "${MINIO_SVC_ACCESS_KEY:minioSvcAccessKey}"
  svc-secret-key: "${MINIO_SVC_SECRET_KEY:minioSvcSecretKey}"
---
postgres:
  host: ${PG_HOST:localhost}
  port: ${PG_PORT:5432}
  database: ${PG_DBNAME:payment}
  username: ${PG_USER:payment}
  password: ${PG_PASSWORD:payment}
  ssl: ${PG_SSL:false}
---
# This is only to allow Micronaut to bootstrap DataSource + JPA;
# overridden at runtime by PostgresDatasourceConfigurationListener#onCreated(BeanCreatedEvent<DatasourceConfiguration>)
datasources:
  default:
    driverClassName: org.postgresql.Driver
    url: "jdbc:postgresql://localhost:5432/payment"
    username: ${PG_USER:payment}
    password: ${PG_PASSWORD:payment}
---
jpa:
 default:
    packages-to-scan:
        - 'pl.altkom.asc.lab.micronaut.poc.payment.domain'
    properties:
        hibernate:
            hbm2ddl:
                auto: update
            show_sql: true
